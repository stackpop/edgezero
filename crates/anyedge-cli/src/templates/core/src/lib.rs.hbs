mod handlers {
    use anyedge_core::{
        action, Body, EdgeError, HeaderName, HeaderValue, IntoResponse, Json, Path, PathParams,
        RequestContext, Response, StatusCode, Text,
    };
    use bytes::Bytes;
    use futures::{stream, StreamExt};
    use std::collections::HashMap;

    #[derive(serde::Deserialize)]
    pub(crate) struct EchoParams {
        pub(crate) name: String,
    }

    #[derive(serde::Deserialize)]
    pub(crate) struct EchoBody {
        pub(crate) name: String,
    }

    #[action]
    pub(crate) async fn root() -> Text<&'static str> {
        Text::new("{{name}} app")
    }

    #[action]
    pub(crate) async fn echo(Path(params): Path<EchoParams>) -> Text<String> {
        Text::new(format!("Hello, {}!", params.name))
    }

    pub(crate) async fn headers(ctx: RequestContext) -> Result<Text<String>, EdgeError> {
        let ua = ctx
            .request()
            .headers()
            .get("User-Agent")
            .and_then(|value| value.to_str().ok())
            .unwrap_or("(unknown)");
        Ok(Text::new(format!("ua={}", ua)))
    }

    #[action]
    pub(crate) async fn stream() -> Response {
        let body = Body::stream(stream::iter(0..3).map(|index| Bytes::from(format!(
            "chunk {}\n",
            index
        ))));

        anyedge_core::response_builder()
            .status(StatusCode::OK)
            .header("content-type", "text/plain; charset=utf-8")
            .body(body)
            .expect("static stream response")
    }

    #[action]
    pub(crate) async fn echo_json(Json(body): Json<EchoBody>) -> Text<String> {
        Text::new(format!("Hello, {}!", body.name))
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use anyedge_core::{request_builder, Body, Method};
        use futures::executor::block_on;

        #[test]
        fn root_returns_static_body() {
            let ctx = empty_context("/");
            let response = block_on(root(ctx)).expect("handler ok").into_response();
            let bytes = response.into_body().into_bytes();
            assert_eq!(bytes.as_ref(), b"{{name}} app");
        }

        #[test]
        fn echo_formats_name_from_path() {
            let ctx = context_with_params("/echo/alice", &[("name", "alice")]);
            let response = block_on(echo(ctx)).expect("handler ok").into_response();
            let bytes = response.into_body().into_bytes();
            assert_eq!(bytes.as_ref(), b"Hello, alice!");
        }

        #[test]
        fn headers_reports_user_agent() {
            let ctx = context_with_header(
                "/headers",
                HeaderName::from_static("user-agent"),
                HeaderValue::from_static("DemoAgent"),
            );

            let response = block_on(headers(ctx)).expect("handler result").into_response();
            let bytes = response.into_body().into_bytes();
            assert_eq!(bytes.as_ref(), b"ua=DemoAgent");
        }

        #[test]
        fn stream_emits_expected_chunks() {
            let ctx = empty_context("/stream");
            let response = block_on(stream(ctx)).expect("handler ok");
            assert_eq!(response.status(), StatusCode::OK);

            let mut chunks = response
                .into_body()
                .into_stream()
                .expect("stream body");
            let collected = block_on(async {
                let mut buf = Vec::new();
                while let Some(chunk) = chunks.next().await {
                    let chunk = chunk.expect("chunk");
                    buf.extend_from_slice(&chunk);
                }
                buf
            });
            assert_eq!(
                String::from_utf8(collected).expect("utf8"),
                "chunk 0\nchunk 1\nchunk 2\n"
            );
        }

        #[test]
        fn echo_json_formats_payload() {
            let ctx = context_with_json(
                "/echo",
                r#"{\"name\":\"Edge\"}"#,
            );
            let response = block_on(echo_json(ctx)).expect("handler ok").into_response();
            let bytes = response.into_body().into_bytes();
            assert_eq!(bytes.as_ref(), b"Hello, Edge!");
        }

        fn empty_context(path: &str) -> RequestContext {
            let request = request_builder()
                .method(Method::GET)
                .uri(path)
                .body(Body::empty())
                .expect("request");
            RequestContext::new(request, PathParams::default())
        }

        fn context_with_params(path: &str, params: &[(&str, &str)]) -> RequestContext {
            let request = request_builder()
                .method(Method::GET)
                .uri(path)
                .body(Body::empty())
                .expect("request");
            let map = params
                .iter()
                .map(|(k, v)| ((*k).to_string(), (*v).to_string()))
                .collect::<HashMap<_, _>>();
            RequestContext::new(request, PathParams::new(map))
        }

        fn context_with_header(
            path: &str,
            header: HeaderName,
            value: HeaderValue,
        ) -> RequestContext {
            let mut request = request_builder()
                .method(Method::GET)
                .uri(path)
                .body(Body::empty())
                .expect("request");
            request.headers_mut().insert(header, value);
            RequestContext::new(request, PathParams::default())
        }

        fn context_with_json(path: &str, json: &str) -> RequestContext {
            let request = request_builder()
                .method(Method::POST)
                .uri(path)
                .body(Body::from(json))
                .expect("request");
            RequestContext::new(request, PathParams::default())
        }
    }
}

mod app {
    use super::handlers::{echo, echo_json, headers, root, stream};
    use anyedge_core::{App, EdgeError, Hooks, RequestContext, RouterService, Text};
    use std::sync::Arc;

    pub struct AppInfo {
        pub name: String,
    }

    pub struct DemoApp;

    impl DemoApp {
        pub fn build_app() -> App {
            <Self as Hooks>::build_app()
        }
    }

    impl Hooks for DemoApp {
        fn routes() -> RouterService {
            let info = Arc::new(AppInfo {
                name: Self::name().to_string(),
            });
            build_router(info)
        }

        fn name() -> &'static str {
            "{{name}}"
        }
    }

    pub fn build_app_with_info(info: AppInfo) -> App {
        let info = Arc::new(info);
        let router = build_router(Arc::clone(&info));
        App::with_name(router, info.name.clone())
    }

    pub fn build_router(info: Arc<AppInfo>) -> RouterService {
        RouterService::builder()
            .get("/", root)
            .get("/echo/{name}", echo)
            .get("/headers", headers)
            .get("/stream", stream)
            .post("/echo", echo_json)
            .get("/info", {
                let info = Arc::clone(&info);
                move |_ctx: RequestContext| {
                    let info = Arc::clone(&info);
                    async move { Ok::<_, EdgeError>(Text::new(format!("App: {}", info.name))) }
                }
            })
            .build()
    }
}

pub use crate::app::{build_app_with_info, build_router, AppInfo, DemoApp};
