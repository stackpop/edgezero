use anyedge_core::action;
use anyedge_core::body::Body;
use anyedge_core::extractor::{Headers, Json, Path};
use anyedge_core::http::{self, Response, StatusCode};
use anyedge_core::response::Text;
use bytes::Bytes;
use futures::{stream, StreamExt};

#[derive(serde::Deserialize)]
pub(crate) struct EchoParams {
    pub(crate) name: String,
}

#[derive(serde::Deserialize)]
pub(crate) struct EchoBody {
    pub(crate) name: String,
}

#[action]
pub(crate) async fn root() -> Text<&'static str> {
    Text::new("{{name}} app")
}

#[action]
pub(crate) async fn echo(Path(params): Path<EchoParams>) -> Text<String> {
    Text::new(format!("Hello, {}!", params.name))
}

#[action]
pub(crate) async fn headers(Headers(headers): Headers) -> Text<String> {
    let ua = headers
        .get("user-agent")
        .and_then(|value| value.to_str().ok())
        .unwrap_or("(unknown)");
    Text::new(format!("ua={}", ua))
}

#[action]
pub(crate) async fn stream() -> Response {
    let body = Body::stream(stream::iter(0..3).map(|index| Bytes::from(format!(
        "chunk {}\n",
        index
    ))));

    http::response_builder()
        .status(StatusCode::OK)
        .header("content-type", "text/plain; charset=utf-8")
        .body(body)
        .expect("static stream response")
}

#[action]
pub(crate) async fn echo_json(Json(body): Json<EchoBody>) -> Text<String> {
    Text::new(format!("Hello, {}!", body.name))
}

#[cfg(test)]
mod tests {
    use super::*;
    use anyedge_core::body::Body;
    use anyedge_core::context::RequestContext;
    use anyedge_core::http::{request_builder, Method, StatusCode};
    use anyedge_core::http::header::{HeaderName, HeaderValue};
    use anyedge_core::params::PathParams;
    use anyedge_core::response::IntoResponse;
    use futures::{executor::block_on, StreamExt};
    use std::collections::HashMap;

    #[test]
    fn root_returns_static_body() {
        let ctx = empty_context("/");
        let response = block_on(root(ctx)).expect("handler ok").into_response();
        let bytes = response.into_body().into_bytes();
        assert_eq!(bytes.as_ref(), b"{{name}} app");
    }

    #[test]
    fn echo_formats_name_from_path() {
        let ctx = context_with_params("/echo/alice", &[("name", "alice")]);
        let response = block_on(echo(ctx)).expect("handler ok").into_response();
        let bytes = response.into_body().into_bytes();
        assert_eq!(bytes.as_ref(), b"Hello, alice!");
    }

    #[test]
    fn headers_reports_user_agent() {
        let ctx = context_with_header(
            "/headers",
            HeaderName::from_static("user-agent"),
            HeaderValue::from_static("DemoAgent"),
        );

        let response = block_on(headers(ctx)).expect("handler ok").into_response();
        let bytes = response.into_body().into_bytes();
        assert_eq!(bytes.as_ref(), b"ua=DemoAgent");
    }

    #[test]
    fn stream_emits_expected_chunks() {
        let ctx = empty_context("/stream");
        let response = block_on(stream(ctx)).expect("handler ok");
        assert_eq!(response.status(), StatusCode::OK);

        let mut chunks = response
            .into_body()
            .into_stream()
            .expect("stream body");
        let collected = block_on(async {
            let mut buf = Vec::new();
            while let Some(chunk) = chunks.next().await {
                let chunk = chunk.expect("chunk");
                buf.extend_from_slice(&chunk);
            }
            buf
        });
        assert_eq!(
            String::from_utf8(collected).expect("utf8"),
            "chunk 0\nchunk 1\nchunk 2\n"
        );
    }

    #[test]
    fn echo_json_formats_payload() {
        let ctx = context_with_json(
            "/echo",
            r#"{"name":"Edge"}"#,
        );
        let response = block_on(echo_json(ctx)).expect("handler ok").into_response();
        let bytes = response.into_body().into_bytes();
        assert_eq!(bytes.as_ref(), b"Hello, Edge!");
    }

    fn empty_context(path: &str) -> RequestContext {
        let request = request_builder()
            .method(Method::GET)
            .uri(path)
            .body(Body::empty())
            .expect("request");
        RequestContext::new(request, PathParams::default())
    }

    fn context_with_params(path: &str, params: &[(&str, &str)]) -> RequestContext {
        let request = request_builder()
            .method(Method::GET)
            .uri(path)
            .body(Body::empty())
            .expect("request");
        let map = params
            .iter()
            .map(|(k, v)| ((*k).to_string(), (*v).to_string()))
            .collect::<HashMap<_, _>>();
        RequestContext::new(request, PathParams::new(map))
    }

    fn context_with_header(
        path: &str,
        header: HeaderName,
        value: HeaderValue,
    ) -> RequestContext {
        let mut request = request_builder()
            .method(Method::GET)
            .uri(path)
            .body(Body::empty())
            .expect("request");
        request.headers_mut().insert(header, value);
        RequestContext::new(request, PathParams::default())
    }

    fn context_with_json(path: &str, json: &str) -> RequestContext {
        let request = request_builder()
            .method(Method::POST)
            .uri(path)
            .body(Body::from(json))
            .expect("request");
        RequestContext::new(request, PathParams::default())
    }
}
