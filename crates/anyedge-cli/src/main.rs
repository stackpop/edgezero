//! AnyEdge CLI.

#[cfg(feature = "cli")]
mod imp {
    use anyedge_core::{App, Method, Request};
    use clap::{Parser, Subcommand};
    use std::io::{Read, Write};
    use std::net::{TcpListener, TcpStream};

    #[derive(Parser, Debug)]
    #[command(name = "anyedge", about = "AnyEdge CLI")]
    pub struct Args {
        #[command(subcommand)]
        pub cmd: Command,
    }

    #[derive(Subcommand, Debug)]
    pub enum Command {
        /// Create a new AnyEdge app skeleton
        New(NewArgs),
        /// Build the project for a target edge
        Build {
            #[arg(long, default_value = "fastly")]
            provider: String,
        },
        /// Deploy to a target edge
        Deploy {
            #[arg(long, default_value = "fastly")]
            provider: String,
        },
        /// Run a local simulation (if available)
        Dev,
    }

    #[derive(clap::Args, Debug)]
    pub struct NewArgs {
        /// Crate/app name (e.g., my-edge-app)
        pub name: String,
        /// Directory to create the app in (default: current dir)
        #[arg(long)]
        pub dir: Option<String>,
        /// Force using a local path dependency to anyedge-core (if available)
        #[arg(long)]
        pub local_core: bool,
    }

    pub fn main() {
        let args = Args::parse();
        match args.cmd {
            Command::New(new_args) => {
                if let Err(e) = cmd_new(new_args) {
                    eprintln!("[anyedge] new error: {e}");
                    std::process::exit(1);
                }
            }
            Command::Build { provider } => {
                println!("[anyedge] build for provider: {} (TODO)", provider);
            }
            Command::Deploy { provider } => {
                println!("[anyedge] deploy to provider: {} (TODO)", provider);
            }
            Command::Dev => {
                println!("[anyedge] dev: starting local server on http://127.0.0.1:8787");
                let app = build_dev_app();
                run_local_server("127.0.0.1:8787", app).expect("failed to run dev server");
            }
        }
    }

    fn cmd_new(args: NewArgs) -> std::io::Result<()> {
        use std::fs;
        use std::path::PathBuf;

        let name = sanitize_crate_name(&args.name);
        let base_dir = args
            .dir
            .as_deref()
            .map(PathBuf::from)
            .unwrap_or_else(|| std::env::current_dir().unwrap());
        let out_dir = base_dir.join(&name);
        if out_dir.exists() {
            return Err(std::io::Error::new(
                std::io::ErrorKind::AlreadyExists,
                format!("directory '{}' already exists", out_dir.display()),
            ));
        }
        fs::create_dir_all(out_dir.join("src"))?;

        let dep_line = detect_local_core_dep(&out_dir, args.local_core)
            .unwrap_or_else(|| "anyedge-core = \"0.1\"".to_string());

        let cargo_toml = format!(
            "[package]\nname = \"{name}\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\nname = \"{name}\"\npath = \"src/lib.rs\"\n\n[dependencies]\n{dep}\n",
            name = name,
            dep = dep_line,
        );
        let lib_rs = r#"use anyedge_core::{App, Request, Response, Method};

pub fn build_app() -> App {
    let mut app = App::new();
    app.get("/", |_req: Request| Response::ok().text("Hello from AnyEdge ðŸ‘‹"));
    app
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn root_ok() {
        let app = build_app();
        let res = app.handle(Request::new(Method::GET, "/"));
        assert_eq!(res.status.as_u16(), 200);
    }
}
"#;
        let readme = format!(
            "# {name}\n\nGenerated by AnyEdge.\n\n- Lib exposes `build_app()` returning an `anyedge_core::App`.\n- For local iteration in this repo, use the CLI dev server: `cargo run -p anyedge-cli --features \"cli,dev-example\" -- dev`.\n\nNote: If building outside the AnyEdge repo, set `anyedge-core` dependency to a published version when available, or change to a local `path` dependency.\n",
            name = name
        );

        fs::write(out_dir.join("Cargo.toml"), cargo_toml)?;
        fs::write(out_dir.join("src/lib.rs"), lib_rs)?;
        fs::write(out_dir.join("README.md"), readme)?;
        println!("[anyedge] created new app at {}", out_dir.display());
        Ok(())
    }

    fn sanitize_crate_name(input: &str) -> String {
        let mut out = String::new();
        for (i, ch) in input.chars().enumerate() {
            let valid = ch.is_ascii_lowercase() || ch.is_ascii_digit() || ch == '-' || ch == '_';
            if valid {
                if i == 0 && ch.is_ascii_digit() {
                    out.push('_');
                }
                out.push(ch);
            } else {
                out.push('-');
            }
        }
        if out.is_empty() {
            "anyedge-app".to_string()
        } else {
            out
        }
    }

    fn detect_local_core_dep(out_dir: &std::path::Path, force: bool) -> Option<String> {
        use std::path::PathBuf;
        if !force {
            if !std::path::Path::new("crates/anyedge-core").exists() {
                return None;
            }
        }
        let cwd = std::env::current_dir().ok()?;
        let workspace_core = cwd.join("crates/anyedge-core");
        if !workspace_core.exists() {
            return None;
        }
        let rel_to_root = relative_to(out_dir, &cwd)?;
        let rel_core = PathBuf::from(rel_to_root).join("crates/anyedge-core");
        Some(format!(
            "anyedge-core = {{ path = \"{}\" }}",
            rel_core.display()
        ))
    }

    fn relative_to(from: &std::path::Path, to: &std::path::Path) -> Option<String> {
        let from_abs = std::fs::canonicalize(from).ok()?;
        let to_abs = std::fs::canonicalize(to).ok()?;
        let suffix = from_abs.strip_prefix(&to_abs).ok()?;
        let depth = suffix.components().count();
        if depth == 0 {
            return Some(".".into());
        }
        let mut ups = String::new();
        for i in 0..depth {
            let _ = i;
            if !ups.is_empty() {
                ups.push('/');
            }
            ups.push_str("..");
        }
        Some(ups)
    }

    // Build an App for dev:
    // - If built with `dev-example`, use the shared app-lib in this workspace.
    // - Otherwise, provide a tiny default app.
    fn build_dev_app() -> App {
        #[cfg(feature = "dev-example")]
        {
            anyedge_app_lib::build_app()
        }
        #[cfg(not(feature = "dev-example"))]
        {
            let mut app = App::new();
            app.get("/", |_req| {
                anyedge_core::Response::ok().text("AnyEdge dev server")
            });
            app
        }
    }

    fn run_local_server(addr: &str, app: App) -> std::io::Result<()> {
        let listener = TcpListener::bind(addr)?;
        // Simple, blocking server. Handle connections sequentially to avoid threading and borrowing issues.
        for stream in listener.incoming() {
            let mut stream = stream?;
            if let Err(e) = handle_conn(&mut stream, &app) {
                eprintln!("[anyedge] conn error: {e}");
            }
        }
        Ok(())
    }

    fn handle_conn(stream: &mut TcpStream, app: &App) -> std::io::Result<()> {
        stream.set_read_timeout(Some(std::time::Duration::from_secs(5)))?;
        let mut buf = [0u8; 8192];
        let mut read = 0usize;
        // Read until we find \r\n\r\n or buffer fills
        loop {
            let n = stream.read(&mut buf[read..])?;
            if n == 0 {
                break;
            }
            read += n;
            if read >= 4 {
                if buf[..read].windows(4).any(|w| w == b"\r\n\r\n") {
                    break;
                }
            }
            if read == buf.len() {
                break;
            }
        }

        let req_text = String::from_utf8_lossy(&buf[..read]);
        let mut lines = req_text.split("\r\n");
        let request_line = lines.next().unwrap_or("");
        let mut parts = request_line.split_whitespace();
        let method = parts.next().unwrap_or("GET");
        let path = parts.next().unwrap_or("/");

        let mut req = Request::new(
            Method::from_bytes(method.as_bytes()).unwrap_or(Method::GET),
            path.to_string(),
        );
        // Headers
        for line in lines {
            if line.is_empty() {
                break;
            }
            if let Some((k, v)) = line.split_once(':') {
                req.append_header(k.trim(), v.trim());
            }
        }
        let res = app.handle(req);

        write_response(stream, res)?;
        Ok(())
    }

    fn write_response(stream: &mut TcpStream, res: anyedge_core::Response) -> std::io::Result<()> {
        let status = res.status.as_u16();
        let reason = match status {
            200 => "OK",
            404 => "Not Found",
            500 => "Internal Server Error",
            _ => "OK",
        };
        let mut out = Vec::new();
        out.extend_from_slice(format!("HTTP/1.1 {} {}\r\n", status, reason).as_bytes());
        let mut has_len = false;
        for (k, v) in res.headers.iter() {
            if k.as_str().eq_ignore_ascii_case("content-length") {
                has_len = true;
            }
            out.extend_from_slice(
                format!("{}: {}\r\n", k.as_str(), v.to_str().unwrap_or("")).as_bytes(),
            );
        }
        if let Some(mut iter) = res.stream {
            if !res
                .headers
                .iter()
                .any(|(k, _)| k.as_str().eq_ignore_ascii_case("transfer-encoding"))
            {
                out.extend_from_slice(b"Transfer-Encoding: chunked\r\n");
            }
            out.extend_from_slice(b"\r\n");
            stream.write_all(&out)?;
            for chunk in &mut iter {
                let line = format!("{:X}\r\n", chunk.len());
                stream.write_all(line.as_bytes())?;
                stream.write_all(&chunk)?;
                stream.write_all(b"\r\n")?;
            }
            stream.write_all(b"0\r\n\r\n")?;
        } else {
            if !has_len {
                out.extend_from_slice(format!("Content-Length: {}\r\n", res.body.len()).as_bytes());
            }
            out.extend_from_slice(b"\r\n");
            out.extend_from_slice(&res.body);
            stream.write_all(&out)?;
        }
        Ok(())
    }
}

#[cfg(not(feature = "cli"))]
mod imp {
    pub fn main() {
        eprintln!("anyedge-cli built without `cli` feature. Rebuild with `--features cli`.");
    }
}

fn main() {
    imp::main()
}
