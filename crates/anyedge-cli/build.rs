use std::env;
use std::fs;
use std::path::PathBuf;
use toml::Value;

fn main() {
    println!("cargo:rerun-if-changed=build.rs");

    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").expect("manifest dir"));
    let manifest_path = manifest_dir.join("Cargo.toml");
    let manifest_str = fs::read_to_string(&manifest_path).expect("read Cargo.toml");
    let manifest: Value = toml::from_str(&manifest_str).expect("parse Cargo.toml");

    let dependencies = manifest
        .get("dependencies")
        .and_then(Value::as_table)
        .cloned()
        .unwrap_or_default();

    let mut adapters: Vec<String> = dependencies
        .into_iter()
        .filter_map(|(name, spec)| {
            if !name.starts_with("anyedge-adapter-") {
                return None;
            }
            let optional = match spec {
                Value::Table(ref table) => table
                    .get("optional")
                    .and_then(Value::as_bool)
                    .unwrap_or(false),
                _ => false,
            };
            if !optional {
                return None;
            }
            let feature_env = format!(
                "CARGO_FEATURE_{}",
                name.replace('-', "_").to_ascii_uppercase()
            );
            println!("cargo:rerun-if-env-changed={feature_env}");
            let enabled = env::var(&feature_env).map(|v| v == "1").unwrap_or(false);
            enabled.then_some(name)
        })
        .collect();

    adapters.sort();
    adapters.dedup();

    let mut generated = String::from("// @generated by build.rs - do not edit manually.\n");

    if adapters.is_empty() {
        generated.push_str("// no adapters enabled for this build\n");
    } else {
        for adapter in adapters {
            let crate_ident = adapter.replace('-', "_");
            generated.push_str(&format!(
                "#[allow(unused_imports)]\npub(crate) use {ident} as _{ident};\n",
                ident = crate_ident
            ));
        }
    }

    let out_path =
        PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR env")).join("linked_adapters.rs");
    fs::write(out_path, generated).expect("write linked_adapters.rs");
}
